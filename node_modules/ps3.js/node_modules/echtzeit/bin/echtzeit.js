/*
                         _      __ 
           ___  ___ ____(_)__  / /_
          / _ \/ -_) __/ / _ \/ __/
         / .__/\__/_/ /_/_//_/\__/ 
        /_/                        

        Copyright (c) 2014 by perint and Kenan Sulayman. All Rights Reserved.

        [Portions/Faye] Copyright (c) 2009-2013 James Coglan and contributors
 
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
 
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
 
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.

        @preserve
*/

'use strict';

var echtzeit = {
        VERSION: '1.6.4',

        BAYEUX_VERSION: '1.0',
        ID_LENGTH: 160,
        JSONP_CALLBACK: 'ezd',
        CONNECTION_TYPES: ['long-polling', 'cross-origin-long-polling', 'callback-polling', 'websocket', 'eventsource', 'in-process'],

        MANDATORY_CONNECTION_TYPES: ['long-polling', 'callback-polling', 'in-process'],

        ENV: (typeof window !== 'undefined') ? window : global,

        fireback: true,

        extend: function(dest, source, overwrite) {
                if (!source) return dest;
                for (var key in source) {
                        if (!source.hasOwnProperty(key)) continue;
                        if (dest.hasOwnProperty(key) && overwrite === false) continue;
                        if (dest[key] !== source[key])
                                dest[key] = source[key];
                }
                return dest;
        },

        random: function(bitlength) {
                bitlength = bitlength || this.ID_LENGTH;
                var maxLength = Math.ceil(bitlength * Math.log(2) / Math.log(36));
                var string = csprng(bitlength, 36);
                while (string.length < maxLength) string = '0' + string;
                return string;
        },

        clientIdFromMessages: function(messages) {
                var connect = this.filter([].concat(messages), function(message) {
                        return message.channel === '/meta/connect';
                });
                return connect[0] && connect[0].clientId;
        },

        copyObject: function(object) {
                var clone, i, key;
                if (object instanceof Array) {
                        clone = [];
                        i = object.length;
                        while (i--) clone[i] = echtzeit.copyObject(object[i]);
                        return clone;
                } else if (typeof object === 'object') {
                        clone = (object === null) ? null : {};
                        for (key in object) clone[key] = echtzeit.copyObject(object[key]);
                        return clone;
                } else {
                        return object;
                }
        },

        commonElement: function(lista, listb) {
                for (var i = 0, n = lista.length; i < n; i++) {
                        if (this.indexOf(listb, lista[i]) !== -1)
                                return lista[i];
                }
                return null;
        },

        indexOf: function(list, needle) {
                if (list.indexOf) return list.indexOf(needle);

                for (var i = 0, n = list.length; i < n; i++) {
                        if (list[i] === needle) return i;
                }
                return -1;
        },

        map: function(object, callback, context) {
                if (object.map) return object.map(callback, context);
                var result = [];

                if (object instanceof Array) {
                        for (var i = 0, n = object.length; i < n; i++) {
                                result.push(callback.call(context || null, object[i], i));
                        }
                } else {
                        for (var key in object) {
                                if (!object.hasOwnProperty(key)) continue;
                                result.push(callback.call(context || null, key, object[key]));
                        }
                }
                return result;
        },

        filter: function(array, callback, context) {
                if (array.filter) return array.filter(callback, context);
                var result = [];
                for (var i = 0, n = array.length; i < n; i++) {
                        if (callback.call(context || null, array[i], i))
                                result.push(array[i]);
                }
                return result;
        },

        asyncEach: function(list, iterator, callback, context) {
                var n = list.length,
                        i = -1,
                        calls = 0,
                        looping = false;

                var iterate = function() {
                        calls -= 1;
                        i += 1;
                        if (i === n) return callback && callback.call(context);
                        iterator(list[i], resume);
                };

                var loop = function() {
                        if (looping) return;
                        looping = true;
                        while (calls > 0) iterate();
                        looping = false;
                };

                var resume = function() {
                        calls += 1;
                        loop();
                };
                resume();
        },

        toJSON: function(object) {
                if (!this.stringify) return JSON.stringify(object);

                return this.stringify(object, function(key, value) {
                        return (this[key] instanceof Array) ? this[key] : value;
                });
        }
};
echtzeit.Class = function(parent, methods) {
	if (typeof parent !== 'function') {
		methods = parent;
		parent  = Object;
	}

	var klass = function() {
		if (!this.initialize) return this;
		return this.initialize.apply(this, arguments) || this;
	};

	var bridge = function() {};
	bridge.prototype = parent.prototype;

	klass.prototype = new bridge();
	echtzeit.extend(klass.prototype, methods);

	return klass;
};

(function() {
var EventEmitter = echtzeit.EventEmitter = function() {};

/*
Copyright Joyent, Inc. and other Node contributors. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

var isArray = typeof Array.isArray === 'function'
		? Array.isArray
		: function (xs) {
				return Object.prototype.toString.call(xs) === '[object Array]'
		}
;
function indexOf (xs, x) {
		if (xs.indexOf) return xs.indexOf(x);
		for (var i = 0; i < xs.length; i++) {
				if (x === xs[i]) return i;
		}
		return -1;
}


EventEmitter.prototype.emit = function(type) {
	// If there is no 'error' event listener then throw.
	if (type === 'error') {
		if (!this._events || !this._events.error ||
				(isArray(this._events.error) && !this._events.error.length))
		{
			if (arguments[1] instanceof Error) {
				throw arguments[1]; // Unhandled 'error' event
			} else {
				throw new Error("Uncaught, unspecified 'error' event.");
			}
			return false;
		}
	}

	if (!this._events) return false;
	var handler = this._events[type];
	if (!handler) return false;

	if (typeof handler == 'function') {
		switch (arguments.length) {
			// fast cases
			case 1:
				handler.call(this);
				break;
			case 2:
				handler.call(this, arguments[1]);
				break;
			case 3:
				handler.call(this, arguments[1], arguments[2]);
				break;
			// slower
			default:
				var args = Array.prototype.slice.call(arguments, 1);
				handler.apply(this, args);
		}
		return true;

	} else if (isArray(handler)) {
		var args = Array.prototype.slice.call(arguments, 1);

		var listeners = handler.slice();
		for (var i = 0, l = listeners.length; i < l; i++) {
			listeners[i].apply(this, args);
		}
		return true;

	} else {
		return false;
	}
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
	if ('function' !== typeof listener) {
		throw new Error('addListener only takes instances of Function');
	}

	if (!this._events) this._events = {};

	// To avoid recursion in the case that type == "newListeners"! Before
	// adding it to the listeners, first emit "newListeners".
	this.emit('newListener', type, listener);

	if (!this._events[type]) {
		// Optimize the case of one listener. Don't need the extra array object.
		this._events[type] = listener;
	} else if (isArray(this._events[type])) {
		// If we've already got an array, just append.
		this._events[type].push(listener);
	} else {
		// Adding the second element, need to change to array.
		this._events[type] = [this._events[type], listener];
	}

	return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
	var self = this;
	self.on(type, function g() {
		self.removeListener(type, g);
		listener.apply(this, arguments);
	});

	return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
	if ('function' !== typeof listener) {
		throw new Error('removeListener only takes instances of Function');
	}

	// does not use listeners(), so no side effect of creating _events[type]
	if (!this._events || !this._events[type]) return this;

	var list = this._events[type];

	if (isArray(list)) {
		var i = indexOf(list, listener);
		if (i < 0) return this;
		list.splice(i, 1);
		if (list.length == 0)
			delete this._events[type];
	} else if (this._events[type] === listener) {
		delete this._events[type];
	}

	return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
	if (arguments.length === 0) {
		this._events = {};
		return this;
	}

	// does not use listeners(), so no side effect of creating _events[type]
	if (type && this._events && this._events[type]) this._events[type] = null;
	return this;
};

EventEmitter.prototype.listeners = function(type) {
	if (!this._events) this._events = {};
	if (!this._events[type]) this._events[type] = [];
	if (!isArray(this._events[type])) {
		this._events[type] = [this._events[type]];
	}
	return this._events[type];
};

})();

echtzeit.Namespace = echtzeit.Class({
	initialize: function() {
		this._used = {};
	},

	exists: function(id) {
		return this._used.hasOwnProperty(id);
	},

	generate: function() {
		var name = echtzeit.random();
		while (this._used.hasOwnProperty(name))
			name = echtzeit.random();
		return this._used[name] = name;
	},

	release: function(id) {
		delete this._used[id];
	}
});

(function() {
'use strict';

var timeout = setTimeout;

var defer;
if (typeof setImmediate === 'function')
	defer = function(fn) { setImmediate(fn) };
else if (typeof process === 'object' && process.nextTick)
	defer = function(fn) { process.nextTick(fn) };
else
	defer = function(fn) { timeout(fn, 0) };

var PENDING   = 0,
		FULFILLED = 1,
		REJECTED  = 2;

var RETURN = function(x) { return x },
		THROW  = function(x) { throw x  };

var Promise = function(task) {
	this._state     = PENDING;
	this._callbacks = [];
	this._errbacks  = [];

	if (typeof task !== 'function') return;
	var self = this;

	task(function(value)  { fulfill(self, value) },
			 function(reason) { reject(self, reason) });
};

Promise.prototype.then = function(callback, errback) {
	var next = {}, self = this;

	next.promise = new Promise(function(fulfill, reject) {
		next.fulfill = fulfill;
		next.reject  = reject;

		registerCallback(self, callback, next);
		registerErrback(self, errback, next);
	});
	return next.promise;
};

var registerCallback = function(promise, callback, next) {
	if (typeof callback !== 'function') callback = RETURN;
	var handler = function(value) { invoke(callback, value, next) };
	if (promise._state === PENDING) {
		promise._callbacks.push(handler);
	} else if (promise._state === FULFILLED) {
		handler(promise._value);
	}
};

var registerErrback = function(promise, errback, next) {
	if (typeof errback !== 'function') errback = THROW;
	var handler = function(reason) { invoke(errback, reason, next) };
	if (promise._state === PENDING) {
		promise._errbacks.push(handler);
	} else if (promise._state === REJECTED) {
		handler(promise._reason);
	}
};

var invoke = function(fn, value, next) {
	defer(function() { _invoke(fn, value, next) });
};

var _invoke = function(fn, value, next) {
	var called = false, outcome, type, then;

	try {
		outcome = fn(value);
		type    = typeof outcome;
		then    = outcome !== null && (type === 'function' || type === 'object') && outcome.then;

		if (outcome === next.promise)
			return next.reject(new TypeError('Recursive promise chain detected'));

		if (typeof then !== 'function') return next.fulfill(outcome);

		then.call(outcome, function(v) {
			if (called) return;
			called = true;
			_invoke(RETURN, v, next);
		}, function(r) {
			if (called) return;
			called = true;
			next.reject(r);
		});

	} catch (error) {
		if (called) return;
		called = true;
		next.reject(error);
	}
};

var fulfill = Promise.fulfill = Promise.resolve = function(promise, value) {
	if (promise._state !== PENDING) return;

	promise._state    = FULFILLED;
	promise._value    = value;
	promise._errbacks = [];

	var callbacks = promise._callbacks, cb;
	while (cb = callbacks.shift()) cb(value);
};

var reject = Promise.reject = function(promise, reason) {
	if (promise._state !== PENDING) return;

	promise._state     = REJECTED;
	promise._reason    = reason;
	promise._callbacks = [];

	var errbacks = promise._errbacks, eb;
	while (eb = errbacks.shift()) eb(reason);
};

Promise.defer = defer;

Promise.deferred = Promise.pending = function() {
	var tuple = {};

	tuple.promise = new Promise(function(fulfill, reject) {
		tuple.fulfill = tuple.resolve = fulfill;
		tuple.reject  = reject;
	});
	return tuple;
};

Promise.fulfilled = Promise.resolved = function(value) {
	return new Promise(function(fulfill, reject) { fulfill(value) });
};

Promise.rejected = function(reason) {
	return new Promise(function(fulfill, reject) { reject(reason) });
};

if (typeof echtzeit === 'undefined')
	module.exports = Promise;
else
	echtzeit.Promise = Promise;

})();

echtzeit.Set = echtzeit.Class({
	initialize: function() {
		this._index = {};
	},

	add: function(item) {
		var key = (item.id !== undefined) ? item.id : item;
		if (this._index.hasOwnProperty(key)) return false;
		this._index[key] = item;
		return true;
	},

	forEach: function(block, context) {
		for (var key in this._index) {
			if (this._index.hasOwnProperty(key))
				block.call(context, this._index[key]);
		}
	},

	isEmpty: function() {
		for (var key in this._index) {
			if (this._index.hasOwnProperty(key)) return false;
		}
		return true;
	},

	member: function(item) {
		for (var key in this._index) {
			if (this._index[key] === item) return true;
		}
		return false;
	},

	remove: function(item) {
		var key = (item.id !== undefined) ? item.id : item;
		var removed = this._index[key];
		delete this._index[key];
		return removed;
	},

	toArray: function() {
		var array = [];
		this.forEach(function(item) { array.push(item) });
		return array;
	}
});

echtzeit.URI = {
	isURI: function(uri) {
		return uri && uri.protocol && uri.host && uri.path;
	},

	isSameOrigin: function(uri) {
		var location = echtzeit.ENV.location;
		return uri.protocol === location.protocol &&
					 uri.hostname === location.hostname &&
					 uri.port     === location.port;
	},

	parse: function(url) {
		if (typeof url !== 'string') return url;
		var uri = {}, parts, query, pairs, i, n, data;

		var consume = function(name, pattern) {
			url = url.replace(pattern, function(match) {
				uri[name] = match;
				return '';
			});
			uri[name] = uri[name] || '';
		};

		consume('protocol', /^[a-z]+\:/i);
		consume('host',     /^\/\/[^\/\?#]+/);

		if (!/^\//.test(url) && !uri.host)
			url = echtzeit.ENV.location.pathname.replace(/[^\/]*$/, '') + url;

		consume('pathname', /^[^\?#]*/);
		consume('search',   /^\?[^#]*/);
		consume('hash',     /^#.*/);

		uri.protocol = uri.protocol || echtzeit.ENV.location.protocol;

		if (uri.host) {
			uri.host     = uri.host.substr(2);
			parts        = uri.host.split(':');
			uri.hostname = parts[0];
			uri.port     = parts[1] || '';
		} else {
			uri.host     = echtzeit.ENV.location.host;
			uri.hostname = echtzeit.ENV.location.hostname;
			uri.port     = echtzeit.ENV.location.port;
		}

		uri.pathname = uri.pathname || '/';
		uri.path = uri.pathname + uri.search;

		query = uri.search.replace(/^\?/, '');
		pairs = query ? query.split('&') : [];
		data  = {};

		for (i = 0, n = pairs.length; i < n; i++) {
			parts = pairs[i].split('=');
			data[decodeURIComponent(parts[0] || '')] = decodeURIComponent(parts[1] || '');
		}

		uri.query = data;

		uri.href = this.stringify(uri);
		return uri;
	},

	stringify: function(uri) {
		var string = uri.protocol + '//' + uri.hostname;
		if (uri.port) string += ':' + uri.port;
		string += uri.pathname + this.queryString(uri.query) + (uri.hash || '');
		return string;
	},

	queryString: function(query) {
		var pairs = [];
		for (var key in query) {
			if (!query.hasOwnProperty(key)) continue;
			pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));
		}
		if (pairs.length === 0) return '';
		return '?' + pairs.join('&');
	}
};

echtzeit.Error = echtzeit.Class({
                initialize: function(code, params, message) {
                        this.code = code;
                        this.params = Array.prototype.slice.call(params);
                        this.message = message;
                },
                toString: function() {
                        return this.code + ':' + this.params.join(',') + ':' + this.message;
                }
        });
echtzeit.Error.parse = function(message) {
        message = message || '';
        if (!echtzeit.Grammar.ERROR.test(message)) return new this(null, [], message);
        var parts = message.split(':'),
                code = parseInt(parts[0]),
                params = parts[1].split(','),
                message = parts[2];
        return new this(code, params, message);
};
echtzeit.Error.versionMismatch = function() {
        return new this(300, arguments, "Version mismatch").toString();
};
echtzeit.Error.conntypeMismatch = function() {
        return new this(301, arguments, "Connection types not supported").toString();
};
echtzeit.Error.extMismatch = function() {
        return new this(302, arguments, "Extension mismatch").toString();
};
echtzeit.Error.badRequest = function() {
        return new this(400, arguments, "Bad request").toString();
};
echtzeit.Error.clientUnknown = function() {
        return new this(401, arguments, "Unknown client").toString();
};
echtzeit.Error.parameterMissing = function() {
        return new this(402, arguments, "Missing required parameter").toString();
};
echtzeit.Error.channelForbidden = function() {
        return new this(403, arguments, "Forbidden channel").toString();
};
echtzeit.Error.channelUnknown = function() {
        return new this(404, arguments, "Unknown channel").toString();
};
echtzeit.Error.channelInvalid = function() {
        return new this(405, arguments, "Invalid channel").toString();
};
echtzeit.Error.extUnknown = function() {
        return new this(406, arguments, "Unknown extension").toString();
};
echtzeit.Error.publishFailed = function() {
        return new this(407, arguments, "Failed to publish").toString();
};
echtzeit.Error.serverError = function() {
        return new this(500, arguments, "Internal server error").toString();
};

echtzeit.Deferrable = {
	then: function(callback, errback) {
		var self = this;
		if (!this._promise)
			this._promise = new echtzeit.Promise(function(fulfill, reject) {
				self._fulfill = fulfill;
				self._reject  = reject;
			});

		if (arguments.length === 0)
			return this._promise;
		else
			return this._promise.then(callback, errback);
	},

	callback: function(callback, context) {
		return this.then(function(value) { callback.call(context, value) });
	},

	errback: function(callback, context) {
		return this.then(null, function(reason) { callback.call(context, reason) });
	},

	timeout: function(seconds, message) {
		this.then();
		var self = this;
		this._timer = echtzeit.ENV.setTimeout(function() {
			self._reject(message);
		}, seconds * 1000);
	},

	setDeferredStatus: function(status, value) {
		if (this._timer) echtzeit.ENV.clearTimeout(this._timer);

		this.then();

		if (status === 'succeeded')
			this._fulfill(value);
		else if (status === 'failed')
			this._reject(value);
		else
			delete this._promise;
	}
};

echtzeit.Publisher = {
	countListeners: function(eventType) {
		return this.listeners(eventType).length;
	},

	bind: function(eventType, listener, context) {
		var slice   = Array.prototype.slice,
				handler = function() { listener.apply(context, slice.call(arguments)) };

		this._listeners = this._listeners || [];
		this._listeners.push([eventType, listener, context, handler]);
		return this.on(eventType, handler);
	},

	unbind: function(eventType, listener, context) {
		this._listeners = this._listeners || [];
		var n = this._listeners.length, tuple;

		while (n--) {
			tuple = this._listeners[n];
			if (tuple[0] !== eventType) continue;
			if (listener && (tuple[1] !== listener || tuple[2] !== context)) continue;
			this._listeners.splice(n, 1);
			this.removeListener(eventType, tuple[3]);
		}
	}
};

echtzeit.extend(echtzeit.Publisher, echtzeit.EventEmitter.prototype);
echtzeit.Publisher.trigger = echtzeit.Publisher.emit;

echtzeit.Timeouts = {
	addTimeout: function(name, delay, callback, context) {
		this._timeouts = this._timeouts || {};
		if (this._timeouts.hasOwnProperty(name)) return;
		var self = this;
		this._timeouts[name] = echtzeit.ENV.setTimeout(function() {
			delete self._timeouts[name];
			callback.call(context);
		}, 1000 * delay);
	},

	removeTimeout: function(name) {
		this._timeouts = this._timeouts || {};
		var timeout = this._timeouts[name];
		if (!timeout) return;
		echtzeit.ENV.clearTimeout(timeout);
		delete this._timeouts[name];
	},

	removeAllTimeouts: function() {
		this._timeouts = this._timeouts || {};
		for (var name in this._timeouts) this.removeTimeout(name);
	}
};

echtzeit.Logging = {
	LOG_LEVELS: {
		fatal:  4,
		error:  3,
		warn:   2,
		info:   1,
		debug:  0
	},

	writeLog: function(messageArgs, level) {
		if (!echtzeit.logger) return;

		var args   = Array.prototype.slice.apply(messageArgs),
				banner = '[echtzeit',
				klass  = this.className,

				message = args.shift().replace(/\?/g, function() {
					try {
						return echtzeit.toJSON(args.shift());
					} catch (e) {
						return '[Object]';
					}
				});

		for (var key in echtzeit) {
			if (klass) continue;
			if (typeof echtzeit[key] !== 'function') continue;
			if (this instanceof echtzeit[key]) klass = key;
		}
		if (klass) banner += '.' + klass;
		banner += '] ';

		if (typeof echtzeit.logger[level] === 'function')
			echtzeit.logger[level](banner + message);
		else if (typeof echtzeit.logger === 'function')
			echtzeit.logger(banner + message);
	}
};

(function() {
	for (var key in echtzeit.Logging.LOG_LEVELS)
		(function(level) {
			echtzeit.Logging[level] = function() {
				this.writeLog(arguments, level);
			};
		})(key);
})();

echtzeit.Grammar = {
	CHANNEL_NAME:     /^\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*$/,
	CHANNEL_PATTERN:  /^(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*\/\*{1,2}$/,
	ERROR:            /^([0-9][0-9][0-9]:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*(,(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)*:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*|[0-9][0-9][0-9]::(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)$/,
	VERSION:          /^([0-9])+(\.(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\-|\_))*)*$/
};

echtzeit.Extensible = {
	addExtension: function(extension) {
		this._extensions = this._extensions || [];
		this._extensions.push(extension);
		if (extension.added) extension.added(this);
	},

	removeExtension: function(extension) {
		if (!this._extensions) return;
		var i = this._extensions.length;
		while (i--) {
			if (this._extensions[i] !== extension) continue;
			this._extensions.splice(i,1);
			if (extension.removed) extension.removed(this);
		}
	},

	pipeThroughExtensions: function(stage, message, request, callback, context) {
		this.debug('Passing through ? extensions: ?', stage, message);

		if (!this._extensions) return callback.call(context, message);
		var extensions = this._extensions.slice();

		var pipe = function(message) {
			if (!message) return callback.call(context, message);

			var extension = extensions.shift();
			if (!extension) return callback.call(context, message);

			var fn = extension[stage];
			if (!fn) return pipe(message);

			if (fn.length >= 3) extension[stage](message, request, pipe);
			else                extension[stage](message, pipe);
		};
		pipe(message);
	}
};

echtzeit.extend(echtzeit.Extensible, echtzeit.Logging);

echtzeit.Channel = echtzeit.Class({
	initialize: function(name) {
		this.id = this.name = name;
	},

	push: function(message) {
		this.trigger('message', message);
	},

	isUnused: function() {
		return this.countListeners('message') === 0;
	}
});

echtzeit.extend(echtzeit.Channel.prototype, echtzeit.Publisher);

echtzeit.extend(echtzeit.Channel, {
	HANDSHAKE:    '/meta/handshake',
	CONNECT:      '/meta/connect',
	SUBSCRIBE:    '/meta/subscribe',
	UNSUBSCRIBE:  '/meta/unsubscribe',
	DISCONNECT:   '/meta/disconnect',

	META:         'meta',
	SERVICE:      'service',

	expand: function(name) {
		var segments = this.parse(name),
				channels = ['/**', name];

		var copy = segments.slice();
		copy[copy.length - 1] = '*';
		channels.push(this.unparse(copy));

		for (var i = 1, n = segments.length; i < n; i++) {
			copy = segments.slice(0, i);
			copy.push('**');
			channels.push(this.unparse(copy));
		}

		return channels;
	},

	isValid: function(name) {
		return echtzeit.Grammar.CHANNEL_NAME.test(name) ||
					 echtzeit.Grammar.CHANNEL_PATTERN.test(name);
	},

	parse: function(name) {
		if (!this.isValid(name)) return null;
		return name.split('/').slice(1);
	},

	unparse: function(segments) {
		return '/' + segments.join('/');
	},

	isMeta: function(name) {
		var segments = this.parse(name);
		return segments ? (segments[0] === this.META) : null;
	},

	isService: function(name) {
		var segments = this.parse(name);
		return segments ? (segments[0] === this.SERVICE) : null;
	},

	isSubscribable: function(name) {
		if (!this.isValid(name)) return null;
		return !this.isMeta(name) && !this.isService(name);
	},

	Set: echtzeit.Class({
		initialize: function() {
			this._channels = {};
		},

		getKeys: function() {
			var keys = [];
			for (var key in this._channels) keys.push(key);
			return keys;
		},

		remove: function(name) {
			delete this._channels[name];
		},

		hasSubscription: function(name) {
			return this._channels.hasOwnProperty(name);
		},

		subscribe: function(names, callback, context) {
			var name;
			for (var i = 0, n = names.length; i < n; i++) {
				name = names[i];
				var channel = this._channels[name] = this._channels[name] || new echtzeit.Channel(name);
				if (callback) channel.bind('message', callback, context);
			}
		},

		unsubscribe: function(name, callback, context) {
			var channel = this._channels[name];
			if (!channel) return false;
			channel.unbind('message', callback, context);

			if (channel.isUnused()) {
				this.remove(name);
				return true;
			} else {
				return false;
			}
		},

		distributeMessage: function(message) {
			var channels = echtzeit.Channel.expand(message.channel);

			for (var i = 0, n = channels.length; i < n; i++) {
				var channel = this._channels[channels[i]];
				if (channel) channel.trigger('message', message.data);
			}
		}
	})
});

echtzeit.Publication = echtzeit.Class(echtzeit.Deferrable);

echtzeit.Subscription = echtzeit.Class({
	initialize: function(client, channels, callback, context) {
		this._client    = client;
		this._channels  = channels;
		this._callback  = callback;
		this._context     = context;
		this._cancelled = false;
	},

	cancel: function() {
		if (this._cancelled) return;
		this._client.unsubscribe(this._channels, this._callback, this._context);
		this._cancelled = true;
	},

	unsubscribe: function() {
		this.cancel();
	}
});

echtzeit.extend(echtzeit.Subscription.prototype, echtzeit.Deferrable);

echtzeit.Client = echtzeit.Class({
	UNCONNECTED:        1,
	CONNECTING:         2,
	CONNECTED:          3,
	DISCONNECTED:       4,

	HANDSHAKE:          'handshake',
	RETRY:              'retry',
	NONE:               'none',

	CONNECTION_TIMEOUT: 60,

	DEFAULT_ENDPOINT:   '/ez',
	INTERVAL:           0,

	initialize: function(endpoint, options) {
		this.info('New client created for ?', endpoint);
		options = options || {};

		this._endpoint   = endpoint || this.DEFAULT_ENDPOINT;
		this._channels   = new echtzeit.Channel.Set();
		this._dispatcher = new echtzeit.Dispatcher(this, this._endpoint, options);

		this._messageId = 0;
		this._state     = this.UNCONNECTED;

		this._responseCallbacks = {};

		this._advice = {
			reconnect: this.RETRY,
			interval:  1000 * (options.interval || this.INTERVAL),
			timeout:   1000 * (options.timeout  || this.CONNECTION_TIMEOUT)
		};
		this._dispatcher.timeout = this._advice.timeout / 1000;

		this._dispatcher.bind('message', this._receiveMessage, this);

		if (echtzeit.Event && echtzeit.ENV.onbeforeunload !== undefined)
			echtzeit.Event.on(echtzeit.ENV, 'beforeunload', function() {
				if (echtzeit.indexOf(this._dispatcher._disabled, 'autodisconnect') < 0)
					this.disconnect();
			}, this);
	},

	disable: function(feature) {
		return this._dispatcher.disable(feature);
	},

	setHeader: function(name, value) {
		return this._dispatcher.setHeader(name, value);
	},

	// Request
	// MUST include:  * channel
	//                * version
	//                * supportedConnectionTypes
	// MAY include:   * minimumVersion
	//                * ext
	//                * id
	//
	// Success Response                             Failed Response
	// MUST include:  * channel                     MUST include:  * channel
	//                * version                                    * successful
	//                * supportedConnectionTypes                   * error
	//                * clientId                    MAY include:   * supportedConnectionTypes
	//                * successful                                 * advice
	// MAY include:   * minimumVersion                             * version
	//                * advice                                     * minimumVersion
	//                * ext                                        * ext
	//                * id                                         * id
	//                * authSuccessful
	handshake: function(callback, context) {
		if (this._advice.reconnect === this.NONE) return;
		if (this._state !== this.UNCONNECTED) return;

		this._state = this.CONNECTING;
		var self = this;

		this.info('Initiating handshake with ?', echtzeit.URI.stringify(this._endpoint));
		this._dispatcher.selectTransport(echtzeit.MANDATORY_CONNECTION_TYPES);

		this._sendMessage({
			channel:                  echtzeit.Channel.HANDSHAKE,
			version:                  echtzeit.BAYEUX_VERSION,
			supportedConnectionTypes: [this._dispatcher.connectionType]

		}, {}, function(response) {

			if (response.successful) {
				this._state = this.CONNECTED;
				this._dispatcher.clientId  = response.clientId;

				this._dispatcher.selectTransport(response.supportedConnectionTypes);

				this.info('Handshake successful: ?', this._dispatcher.clientId);

				this.subscribe(this._channels.getKeys(), true);
				if (callback) echtzeit.Promise.defer(function() { callback.call(context) });

			} else {
				this.info('Handshake unsuccessful');
				echtzeit.ENV.setTimeout(function() { self.handshake(callback, context) }, this._dispatcher.retry * 1000);
				this._state = this.UNCONNECTED;
			}
		}, this);
	},

	// Request                              Response
	// MUST include:  * channel             MUST include:  * channel
	//                * clientId                           * successful
	//                * connectionType                     * clientId
	// MAY include:   * ext                 MAY include:   * error
	//                * id                                 * advice
	//                                                     * ext
	//                                                     * id
	//                                                     * timestamp
	connect: function(callback, context) {
		if (this._advice.reconnect === this.NONE) return;
		if (this._state === this.DISCONNECTED) return;

		if (this._state === this.UNCONNECTED)
			return this.handshake(function() { this.connect(callback, context) }, this);

		this.callback(callback, context);
		if (this._state !== this.CONNECTED) return;

		this.info('Calling deferred actions for ?', this._dispatcher.clientId);
		this.setDeferredStatus('succeeded');
		this.setDeferredStatus('unknown');

		if (this._connectRequest) return;
		this._connectRequest = true;

		this.info('Initiating connection for ?', this._dispatcher.clientId);

		this._sendMessage({
			channel:        echtzeit.Channel.CONNECT,
			clientId:       this._dispatcher.clientId,
			connectionType: this._dispatcher.connectionType

		}, {}, this._cycleConnection, this);
	},

	// Request                              Response
	// MUST include:  * channel             MUST include:  * channel
	//                * clientId                           * successful
	// MAY include:   * ext                                * clientId
	//                * id                  MAY include:   * error
	//                                                     * ext
	//                                                     * id
	disconnect: function() {
		if (this._state !== this.CONNECTED) return;
		this._state = this.DISCONNECTED;

		this.info('Disconnecting ?', this._dispatcher.clientId);

		this._sendMessage({
			channel:  echtzeit.Channel.DISCONNECT,
			clientId: this._dispatcher.clientId

		}, {}, function(response) {
			if (response.successful) this._dispatcher.close();
		}, this);

		this.info('Clearing channel listeners for ?', this._dispatcher.clientId);
		this._channels = new echtzeit.Channel.Set();
	},

	// Request                              Response
	// MUST include:  * channel             MUST include:  * channel
	//                * clientId                           * successful
	//                * subscription                       * clientId
	// MAY include:   * ext                                * subscription
	//                * id                  MAY include:   * error
	//                                                     * advice
	//                                                     * ext
	//                                                     * id
	//                                                     * timestamp
	subscribe: function(channel, callback, context) {
		if (channel instanceof Array)
			return echtzeit.map(channel, function(c) {
				return this.subscribe(c, callback, context);
			}, this);

		var subscription = new echtzeit.Subscription(this, channel, callback, context),
				force        = (callback === true),
				hasSubscribe = this._channels.hasSubscription(channel);

		if (hasSubscribe && !force) {
			this._channels.subscribe([channel], callback, context);
			subscription.setDeferredStatus('succeeded');
			return subscription;
		}

		this.connect(function() {
			this.info('Client ? attempting to subscribe to ?', this._dispatcher.clientId, channel);
			if (!force) this._channels.subscribe([channel], callback, context);

			this._sendMessage({
				channel:      echtzeit.Channel.SUBSCRIBE,
				clientId:     this._dispatcher.clientId,
				subscription: channel

			}, {}, function(response) {
				if (!response.successful) {
					subscription.setDeferredStatus('failed', echtzeit.Error.parse(response.error));
					return this._channels.unsubscribe(channel, callback, context);
				}

				var channels = [].concat(response.subscription);
				this.info('Subscription acknowledged for ? to ?', this._dispatcher.clientId, channels);
				subscription.setDeferredStatus('succeeded');
			}, this);
		}, this);

		return subscription;
	},

	// Request                              Response
	// MUST include:  * channel             MUST include:  * channel
	//                * clientId                           * successful
	//                * subscription                       * clientId
	// MAY include:   * ext                                * subscription
	//                * id                  MAY include:   * error
	//                                                     * advice
	//                                                     * ext
	//                                                     * id
	//                                                     * timestamp
	unsubscribe: function(channel, callback, context) {
		if (channel instanceof Array)
			return echtzeit.map(channel, function(c) {
				return this.unsubscribe(c, callback, context);
			}, this);

		var dead = this._channels.unsubscribe(channel, callback, context);
		if (!dead) return;

		this.connect(function() {
			this.info('Client ? attempting to unsubscribe from ?', this._dispatcher.clientId, channel);

			this._sendMessage({
				channel:      echtzeit.Channel.UNSUBSCRIBE,
				clientId:     this._dispatcher.clientId,
				subscription: channel

			}, {}, function(response) {
				if (!response.successful) return;

				var channels = [].concat(response.subscription);
				this.info('Unsubscription acknowledged for ? from ?', this._dispatcher.clientId, channels);
			}, this);
		}, this);
	},

	// Request                              Response
	// MUST include:  * channel             MUST include:  * channel
	//                * data                               * successful
	// MAY include:   * clientId            MAY include:   * id
	//                * id                                 * error
	//                * ext                                * ext
	publish: function(channel, data, options) {
		var publication = new echtzeit.Publication();

		this.connect(function() {
			this.info('Client ? queueing published message to ?: ?', this._dispatcher.clientId, channel, data);

			this._sendMessage({
				channel:  channel,
				data:     data,
				clientId: this._dispatcher.clientId

			}, options, function(response) {
				if (response.successful)
					publication.setDeferredStatus('succeeded');
				else
					publication.setDeferredStatus('failed', echtzeit.Error.parse(response.error));
			}, this);
		}, this);

		return publication;
	},

	_sendMessage: function(message, options, callback, context) {
		message.id = this._generateMessageId();

		var timeout = this._advice.timeout
								? 1.2 * this._advice.timeout / 1000
								: 1.2 * this._dispatcher.retry;

		this.pipeThroughExtensions('outgoing', message, null, function(message) {
			if (!message) return;
			if (callback) this._responseCallbacks[message.id] = [callback, context];
			this._dispatcher.sendMessage(message, timeout, options || {});
		}, this);
	},

	_generateMessageId: function() {
		this._messageId += 1;
		if (this._messageId >= Math.pow(2,32)) this._messageId = 0;
		return this._messageId.toString(36);
	},

	_receiveMessage: function(message) {
		var id = message.id, callback;

		if (message.successful !== undefined) {
			callback = this._responseCallbacks[id];
			delete this._responseCallbacks[id];
		}

		this.pipeThroughExtensions('incoming', message, null, function(message) {
			if (!message) return;
			if (message.advice) this._handleAdvice(message.advice);
			this._deliverMessage(message);
			if (callback) callback[0].call(callback[1], message);
		}, this);
	},

	_handleAdvice: function(advice) {
		echtzeit.extend(this._advice, advice);
		this._dispatcher.timeout = this._advice.timeout / 1000;

		if (this._advice.reconnect === this.HANDSHAKE && this._state !== this.DISCONNECTED) {
			this._state = this.UNCONNECTED;
			this._dispatcher.clientId = null;
			this._cycleConnection();
		}
	},

	_deliverMessage: function(message) {
		if (!message.channel || message.data === undefined) return;
		this.info('Client ? calling listeners for ? with ?', this._dispatcher.clientId, message.channel, message.data);
		this._channels.distributeMessage(message);
	},

	_cycleConnection: function() {
		if (this._connectRequest) {
			this._connectRequest = null;
			this.info('Closed connection for ?', this._dispatcher.clientId);
		}
		var self = this;
		echtzeit.ENV.setTimeout(function() { self.connect() }, this._advice.interval);
	}
});

echtzeit.extend(echtzeit.Client.prototype, echtzeit.Deferrable);
echtzeit.extend(echtzeit.Client.prototype, echtzeit.Publisher);
echtzeit.extend(echtzeit.Client.prototype, echtzeit.Logging);
echtzeit.extend(echtzeit.Client.prototype, echtzeit.Extensible);

echtzeit.Dispatcher = echtzeit.Class({
	MAX_REQUEST_SIZE: 2048,
	DEFAULT_RETRY:    5,

	UP:   1,
	DOWN: 2,

	initialize: function(client, endpoint, options) {
		this._client     = client;
		this.endpoint    = echtzeit.URI.parse(endpoint);
		this._alternates = options.endpoints || {};

		this.ca         = options.ca;
		this.cookies    = echtzeit.Cookies && new echtzeit.Cookies.CookieJar();
		this._disabled  = [];
		this._envelopes = {};
		this.headers    = {};
		this.retry      = options.retry || this.DEFAULT_RETRY;
		this._state     = 0;
		this.transports = {};

		for (var type in this._alternates)
			this._alternates[type] = echtzeit.URI.parse(this._alternates[type]);

		this.maxRequestSize = this.MAX_REQUEST_SIZE;
	},

	endpointFor: function(connectionType) {
		return this._alternates[connectionType] || this.endpoint;
	},

	disable: function(feature) {
		this._disabled.push(feature);
	},

	setHeader: function(name, value) {
		this.headers[name] = value;
	},

	close: function() {
		var transport = this._transport;
		delete this._transport;
		if (transport) transport.close();
	},

	selectTransport: function(transportTypes) {
		echtzeit.Transport.get(this, transportTypes, this._disabled, function(transport) {
			this.debug('Selected ? transport for ?', transport.connectionType, echtzeit.URI.stringify(transport.endpoint));

			if (transport === this._transport) return;
			if (this._transport) this._transport.close();

			this._transport = transport;
			this.connectionType = transport.connectionType;
		}, this);
	},

	sendMessage: function(message, timeout, options) {
		if (!this._transport) return;
		options = options || {};

		var self     = this,
				id       = message.id,
				attempts = options.attempts,
				deadline = options.deadline && new Date().getTime() + (options.deadline * 1000),

				envelope = this._envelopes[id] = this._envelopes[id] ||
									 {message: message, timeout: timeout, attempts: attempts, deadline: deadline};

		if (envelope.request || envelope.timer) return;

		if (this._attemptsExhausted(envelope) || this._deadlinePassed(envelope)) {
			delete this._envelopes[id];
			return;
		}

		envelope.timer = echtzeit.ENV.setTimeout(function() {
			self.handleError(message);
		}, timeout * 1000);

		envelope.request = this._transport.sendMessage(message);
	},

	handleResponse: function(reply) {
		var envelope = this._envelopes[reply.id];

		if (reply.successful !== undefined && envelope) {
			delete this._envelopes[reply.id];
			echtzeit.ENV.clearTimeout(envelope.timer);
		}

		this.trigger('message', reply);

		if (this._state === this.UP) return;
		this._state = this.UP;
		this._client.trigger('transport:up');
	},

	handleError: function(message, immediate) {
		var envelope = this._envelopes[message.id],
				request  = envelope && envelope.request,
				self     = this;

		if (!request) return;

		request.then(function(req) {
			if (req && req.abort) req.abort();
		});

		echtzeit.ENV.clearTimeout(envelope.timer);
		envelope.request = envelope.timer = null;

		if (immediate) {
			this.sendMessage(envelope.message, envelope.timeout);
		} else {
			envelope.timer = echtzeit.ENV.setTimeout(function() {
				envelope.timer = null;
				self.sendMessage(envelope.message, envelope.timeout);
			}, this.retry * 1000);
		}

		if (this._state === this.DOWN) return;
		this._state = this.DOWN;
		this._client.trigger('transport:down');
	},

	_attemptsExhausted: function(envelope) {
		if (envelope.attempts === undefined) return false;
		envelope.attempts -= 1;
		if (envelope.attempts >= 0) return false;
		return true;
	},

	_deadlinePassed: function(envelope) {
		var deadline = envelope.deadline;
		if (deadline === undefined) return false;
		if (new Date().getTime() <= deadline) return false;
		return true;
	}
});

echtzeit.extend(echtzeit.Dispatcher.prototype, echtzeit.Publisher);
echtzeit.extend(echtzeit.Dispatcher.prototype, echtzeit.Logging);

echtzeit.Transport = echtzeit.extend(echtzeit.Class({
	MAX_DELAY: 0,
	batching:  true,

	initialize: function(dispatcher, endpoint) {
		this._dispatcher = dispatcher;
		this.endpoint    = endpoint;
		this._outbox     = [];
	},

	close: function() {},

	encode: function(messages) {
		return '';
	},

	sendMessage: function(message) {
		this.debug('Client ? sending message to ?: ?',
							 this._dispatcher.clientId, echtzeit.URI.stringify(this.endpoint), message);

		if (!this.batching) return echtzeit.Promise.fulfilled(this.request([message]));

		this._promise = this._promise || new echtzeit.Promise();
		this._outbox.push(message);
		this._flushLargeBatch();

		if (message.channel === echtzeit.Channel.HANDSHAKE) {
			this.addTimeout('publish', 0.01, this._flush, this);
			return this._promise;
		}

		if (message.channel === echtzeit.Channel.CONNECT)
			this._connectMessage = message;

		this.addTimeout('publish', this.MAX_DELAY, this._flush, this);
		return this._promise;
	},

	_flush: function() {
		this.removeTimeout('publish');

		if (this._outbox.length > 1 && this._connectMessage)
			this._connectMessage.advice = {timeout: 0};

		echtzeit.Promise.fulfill(this._promise, this.request(this._outbox));
		delete this._promise;

		this._connectMessage = null;
		this._outbox = [];
	},

	_flushLargeBatch: function() {
		var string = this.encode(this._outbox);
		if (string.length < this._dispatcher.maxRequestSize) return;
		var last = this._outbox.pop();
		this._flush();
		if (last) this._outbox.push(last);
	},

	_receive: function(replies) {
		replies = [].concat(replies);

		this.debug('Client ? received from ? via ?: ?',
							 this._dispatcher.clientId, echtzeit.URI.stringify(this.endpoint), this.connectionType, replies);

		for (var i = 0, n = replies.length; i < n; i++)
			this._dispatcher.handleResponse(replies[i]);
	},

	_handleError: function(messages, immediate) {
		messages = [].concat(messages);

		this.debug('Client ? failed to send to ? via ?: ?',
							 this._dispatcher.clientId, echtzeit.URI.stringify(this.endpoint), this.connectionType, messages);

		for (var i = 0, n = messages.length; i < n; i++)
			this._dispatcher.handleError(messages[i]);
	},

	_getCookies: function() {
		var cookies = this._dispatcher.cookies,
				url     = echtzeit.URI.stringify(this.endpoint);

		if (!cookies) return '';

		return echtzeit.map(cookies.getCookiesSync(url), function(cookie) {
			return cookie.cookieString();
		}).join('; ');
	},

	_storeCookies: function(setCookie) {
		var cookies = this._dispatcher.cookies,
				url     = echtzeit.URI.stringify(this.endpoint),
				cookie;

		if (!setCookie || !cookies) return;
		setCookie = [].concat(setCookie);

		for (var i = 0, n = setCookie.length; i < n; i++) {
			cookie = echtzeit.Cookies.Cookie.parse(setCookie[i]);
			cookies.setCookieSync(cookie, url);
		}
	}

}), {
	get: function(dispatcher, allowed, disabled, callback, context) {
		var endpoint = dispatcher.endpoint;

		echtzeit.asyncEach(this._transports, function(pair, resume) {
			var connType     = pair[0], klass = pair[1],
					connEndpoint = dispatcher.endpointFor(connType);

			if (echtzeit.indexOf(disabled, connType) >= 0)
				return resume();

			if (echtzeit.indexOf(allowed, connType) < 0) {
				klass.isUsable(dispatcher, connEndpoint, function() {});
				return resume();
			}

			klass.isUsable(dispatcher, connEndpoint, function(isUsable) {
				if (!isUsable) return resume();
				var transport = klass.hasOwnProperty('create') ? klass.create(dispatcher, connEndpoint) : new klass(dispatcher, connEndpoint);
				callback.call(context, transport);
			});
		}, function() {
			throw new Error('Could not find a usable connection type for ' + echtzeit.URI.stringify(endpoint));
		});
	},

	register: function(type, klass) {
		this._transports.push([type, klass]);
		klass.prototype.connectionType = type;
	},

	_transports: []
});

echtzeit.extend(echtzeit.Transport.prototype, echtzeit.Logging);
echtzeit.extend(echtzeit.Transport.prototype, echtzeit.Timeouts);

echtzeit.Engine = {
	get: function(options) {
		return new echtzeit.Engine.Proxy(options);
	},

	METHODS: ['createClient', 'clientExists', 'destroyClient', 'ping', 'subscribe', 'unsubscribe']
};

echtzeit.Engine.Proxy = echtzeit.Class({
	MAX_DELAY:  0,
	INTERVAL:   0,
	TIMEOUT:    60,

	className: 'Engine',

	initialize: function(options) {
		this._options     = options || {};
		this._connections = {};
		this.interval     = this._options.interval || this.INTERVAL;
		this.timeout      = this._options.timeout  || this.TIMEOUT;

		var engineClass = this._options.type || echtzeit.Engine.Memory;
		this._engine    = engineClass.create(this, this._options);

		this.bind('close', function(clientId) {
			var self = this;
			echtzeit.Promise.defer(function() { self.flushConnection(clientId) });
		}, this);

		this.debug('Created new engine: ?', this._options);
	},

	connect: function(clientId, options, callback, context) {
		this.debug('Accepting connection from ?', clientId);
		this._engine.ping(clientId);
		var conn = this.connection(clientId, true);
		conn.connect(options, callback, context);
		this._engine.emptyQueue(clientId);
	},

	hasConnection: function(clientId) {
		return this._connections.hasOwnProperty(clientId);
	},

	connection: function(clientId, create) {
		var conn = this._connections[clientId];
		if (conn || !create) return conn;
		this._connections[clientId] = new echtzeit.Engine.Connection(this, clientId);
		this.trigger('connection:open', clientId);
		return this._connections[clientId];
	},

	closeConnection: function(clientId) {
		this.debug('Closing connection for ?', clientId);
		var conn = this._connections[clientId];
		if (!conn) return;
		if (conn.socket) conn.socket.close();
		this.trigger('connection:close', clientId);
		delete this._connections[clientId];
	},

	openSocket: function(clientId, socket) {
		var conn = this.connection(clientId, true);
		conn.socket = socket;
	},

	deliver: function(clientId, messages) {
		if (!messages || messages.length === 0) return false;

		var conn = this.connection(clientId, false);
		if (!conn) return false;

		for (var i = 0, n = messages.length; i < n; i++) {
			conn.deliver(messages[i]);
		}
		return true;
	},

	generateId: function() {
		return echtzeit.random();
	},

	flushConnection: function(clientId, close) {
		if (!clientId) return;
		this.debug('Flushing connection for ?', clientId);
		var conn = this.connection(clientId, false);
		if (!conn) return;
		if (close === false) conn.socket = null;
		conn.flush();
		this.closeConnection(clientId);
	},

	close: function() {
		for (var clientId in this._connections) this.flushConnection(clientId);
		this._engine.disconnect();
	},

	disconnect: function() {
		if (this._engine.disconnect) return this._engine.disconnect();
	},

	publish: function(message) {
		var channels = echtzeit.Channel.expand(message.channel);
		return this._engine.publish(message, channels);
	}
});

echtzeit.Engine.METHODS.forEach(function(method) {
	echtzeit.Engine.Proxy.prototype[method] = function() {
		return this._engine[method].apply(this._engine, arguments);
	};
});

echtzeit.extend(echtzeit.Engine.Proxy.prototype, echtzeit.Publisher);
echtzeit.extend(echtzeit.Engine.Proxy.prototype, echtzeit.Logging);

echtzeit.Engine.Connection = echtzeit.Class({
	initialize: function(engine, id, options) {
		this._engine  = engine;
		this._id      = id;
		this._options = options;
		this._inbox   = [];
	},

	deliver: function(message) {
		if (this.socket) return this.socket.send(message);
		this._inbox.push(message);
		this._beginDeliveryTimeout();
	},

	connect: function(options, callback, context) {
		options = options || {};
		var timeout = (options.timeout !== undefined) ? options.timeout / 1000 : this._engine.timeout;

		this.setDeferredStatus('unknown');
		this.callback(callback, context);

		this._beginDeliveryTimeout();
		this._beginConnectionTimeout(timeout);
	},

	flush: function() {
		this.removeTimeout('connection');
		this.removeTimeout('delivery');

		this.setDeferredStatus('succeeded', this._inbox);
		this._inbox = [];

		if (!this.socket) this._engine.closeConnection(this._id);
	},

	_beginDeliveryTimeout: function() {
		if (this._inbox.length === 0) return;
		this.addTimeout('delivery', this._engine.MAX_DELAY, this.flush, this);
	},

	_beginConnectionTimeout: function(timeout) {
		this.addTimeout('connection', timeout, this.flush, this);
	}
});

echtzeit.extend(echtzeit.Engine.Connection.prototype, echtzeit.Deferrable);
echtzeit.extend(echtzeit.Engine.Connection.prototype, echtzeit.Timeouts);

echtzeit.Engine.Memory = function(server, options) {
	this._server = server;
	this._options = options || {};
	this.reset();
};

echtzeit.Engine.Memory.create = function(server, options) {
	return new this(server, options);
};

echtzeit.Engine.Memory.prototype = {
	disconnect: function() {
		this.reset();
		this.removeAllTimeouts();
	},

	reset: function() {
		this._namespace = new echtzeit.Namespace();
		this._clients = {};
		this._channels = {};
		this._messages = {};
	},

	createClient: function(callback, context) {
		var clientId = this._namespace.generate();
		this._server.debug('Created new client ?', clientId);
		this.ping(clientId);
		this._server.trigger('handshake', clientId);
		callback.call(context, clientId);
	},

	destroyClient: function(clientId, callback, context) {
		if (!this._namespace.exists(clientId)) return;
		var clients = this._clients;

		if (clients[clientId])
			clients[clientId].forEach(function(channel) {
				this.unsubscribe(clientId, channel)
			}, this);

		this.removeTimeout(clientId);
		this._namespace.release(clientId);
		delete this._messages[clientId];
		this._server.debug('Destroyed client ?', clientId);
		this._server.trigger('disconnect', clientId);
		this._server.trigger('close', clientId);
		if (callback) callback.call(context);
	},

	clientExists: function(clientId, callback, context) {
		callback.call(context, this._namespace.exists(clientId));
	},

	ping: function(clientId) {
		var timeout = this._server.timeout;
		if (typeof timeout !== 'number') return;

		this._server.debug('Ping ?, ?', clientId, timeout);
		this.removeTimeout(clientId);
		this.addTimeout(clientId, 2 * timeout, function() {
			this.destroyClient(clientId);
		}, this);
	},

	subscribe: function(clientId, channel, callback, context) {
		var clients = this._clients,
			channels = this._channels;

		clients[clientId] = clients[clientId] || new echtzeit.Set();
		var trigger = clients[clientId].add(channel);

		channels[channel] = channels[channel] || new echtzeit.Set();
		channels[channel].add(clientId);

		this._server.debug('Subscribed client ? to channel ?', clientId, channel);
		if (trigger) this._server.trigger('subscribe', clientId, channel);
		if (callback) callback.call(context, true);
	},

	unsubscribe: function(clientId, channel, callback, context) {
		var clients = this._clients,
			channels = this._channels,
			trigger = false;

		if (clients[clientId]) {
			trigger = clients[clientId].remove(channel);
			if (clients[clientId].isEmpty()) delete clients[clientId];
		}

		if (channels[channel]) {
			channels[channel].remove(clientId);
			if (channels[channel].isEmpty()) delete channels[channel];
		}

		this._server.debug('Unsubscribed client ? from channel ?', clientId, channel);
		if (trigger) this._server.trigger('unsubscribe', clientId, channel);
		if (callback) callback.call(context, true);
	},

	publish: function(message, channels) {
		this._server.debug('Publishing message ?', message);

		var messages = this._messages,
			clients = new echtzeit.Set(),
			subs;

		for (var i = 0, n = channels.length; i < n; i++) {
			subs = this._channels[channels[i]];
			if (!subs) continue;
			subs.forEach(clients.add, clients);
		}

		clients.forEach(function(clientId) {
			if (!echtzeit.fireback && clientId === message.clientId) return false;
			this._server.debug('Queueing for client ?: ?', clientId, message);
			messages[clientId] = messages[clientId] || [];
			messages[clientId].push(echtzeit.copyObject(message));
			this.emptyQueue(clientId);
		}, this);

		this._server.trigger('publish', message.clientId, message.channel, message.data);
	},

	emptyQueue: function(clientId) {
		if (!this._server.hasConnection(clientId)) return;
		this._server.deliver(clientId, this._messages[clientId]);
		delete this._messages[clientId];
	}
};
echtzeit.extend(echtzeit.Engine.Memory.prototype, echtzeit.Timeouts);
echtzeit.Server = echtzeit.Class({
	META_METHODS: ['handshake', 'connect', 'disconnect', 'subscribe', 'unsubscribe'],

	initialize: function(options) {
		this._options  = options || {};
		var engineOpts = this._options.engine || {};
		engineOpts.timeout = this._options.timeout;
		this._engine   = echtzeit.Engine.get(engineOpts);

		this.info('Created new server: ?', this._options);
	},

	close: function() {
		return this._engine.close();
	},

	openSocket: function(clientId, socket, request) {
		if (!clientId || !socket) return;
		this._engine.openSocket(clientId, new echtzeit.Server.Socket(this, socket, request));
	},

	closeSocket: function(clientId, close) {
		this._engine.flushConnection(clientId, close);
	},

	process: function(messages, request, callback, context) {
		var local = (request === null);

		messages = [].concat(messages);
		this.info('Processing messages: ? (local: ?)', messages, local);

		if (messages.length === 0) return callback.call(context, []);
		var processed = 0, responses = [], self = this;

		var gatherReplies = function(replies) {
			responses = responses.concat(replies);
			processed += 1;
			if (processed < messages.length) return;

			var n = responses.length;
			while (n--) {
				if (!responses[n]) responses.splice(n,1);
			}
			self.info('Returning replies: ?', responses);
			callback.call(context, responses);
		};

		var handleReply = function(replies) {
			var extended = 0, expected = replies.length;
			if (expected === 0) gatherReplies(replies);

			for (var i = 0, n = replies.length; i < n; i++) {
				this.debug('Processing reply: ?', replies[i]);
				(function(index) {
					self.pipeThroughExtensions('outgoing', replies[index], request, function(message) {
						replies[index] = message;
						extended += 1;
						if (extended === expected) gatherReplies(replies);
					});
				})(i);
			}
		};

		for (var i = 0, n = messages.length; i < n; i++) {
			this.pipeThroughExtensions('incoming', messages[i], request, function(pipedMessage) {
				this._handle(pipedMessage, local, handleReply, this);
			}, this);
		}
	},

	_makeResponse: function(message) {
		var response = {};

		if (message.id)       response.id       = message.id;
		if (message.clientId) response.clientId = message.clientId;
		if (message.channel)  response.channel  = message.channel;
		if (message.error)    response.error    = message.error;

		response.successful = !response.error;
		return response;
	},

	_handle: function(message, local, callback, context) {
		if (!message) return callback.call(context, []);
		this.info('Handling message: ? (local: ?)', message, local);

		var channelName = message.channel,
				error       = message.error,
				response;

		if (echtzeit.Channel.isMeta(channelName))
			return this._handleMeta(message, local, callback, context);

		if (!echtzeit.Grammar.CHANNEL_NAME.test(channelName))
			error = echtzeit.Error.channelInvalid(channelName);

		delete message.clientId;
		if (!error) this._engine.publish(message);

		response = this._makeResponse(message);
		if (error) response.error = error;
		response.successful = !response.error;
		callback.call(context, [response]);
	},

	_handleMeta: function(message, local, callback, context) {
		var method = echtzeit.Channel.parse(message.channel)[1],
				response;

		if (echtzeit.indexOf(this.META_METHODS, method) < 0) {
			response = this._makeResponse(message);
			response.error = echtzeit.Error.channelForbidden(message.channel);
			response.successful = false;
			return callback.call(context, [response]);
		}

		this[method](message, local, function(responses) {
			responses = [].concat(responses);
			for (var i = 0, n = responses.length; i < n; i++) this._advize(responses[i], message.connectionType);
			callback.call(context, responses);
		}, this);
	},

	_advize: function(response, connectionType) {
		if (echtzeit.indexOf([echtzeit.Channel.HANDSHAKE, echtzeit.Channel.CONNECT], response.channel) < 0)
			return;

		var interval, timeout;
		if (connectionType === 'eventsource') {
			interval = Math.floor(this._engine.timeout * 1000);
			timeout  = 0;
		} else {
			interval = Math.floor(this._engine.interval * 1000);
			timeout  = Math.floor(this._engine.timeout * 1000);
		}

		response.advice = response.advice || {};
		if (response.error) {
			echtzeit.extend(response.advice, {reconnect:  'handshake'}, false);
		} else {
			echtzeit.extend(response.advice, {
				reconnect:  'retry',
				interval:   interval,
				timeout:    timeout
			}, false);
		}
	},

	// MUST contain  * version
	//               * supportedConnectionTypes
	// MAY contain   * minimumVersion
	//               * ext
	//               * id
	handshake: function(message, local, callback, context) {
		var response = this._makeResponse(message);
		response.version = echtzeit.BAYEUX_VERSION;

		if (!message.version)
			response.error = echtzeit.Error.parameterMissing('version');

		var clientConns = message.supportedConnectionTypes,
				commonConns;

		response.supportedConnectionTypes = echtzeit.CONNECTION_TYPES;

		if (clientConns) {
			commonConns = echtzeit.filter(clientConns, function(conn) {
				return echtzeit.indexOf(echtzeit.CONNECTION_TYPES, conn) >= 0;
			});
			if (commonConns.length === 0)
				response.error = echtzeit.Error.conntypeMismatch(clientConns);
		} else {
			response.error = echtzeit.Error.parameterMissing('supportedConnectionTypes');
		}

		response.successful = !response.error;
		if (!response.successful) return callback.call(context, response);

		this._engine.createClient(function(clientId) {
			response.clientId = clientId;
			callback.call(context, response);
		}, this);
	},

	// MUST contain  * clientId
	//               * connectionType
	// MAY contain   * ext
	//               * id
	connect: function(message, local, callback, context) {
		var response       = this._makeResponse(message),
				clientId       = message.clientId,
				connectionType = message.connectionType;

		this._engine.clientExists(clientId, function(exists) {
			if (!exists)         response.error = echtzeit.Error.clientUnknown(clientId);
			if (!clientId)       response.error = echtzeit.Error.parameterMissing('clientId');

			if (echtzeit.indexOf(echtzeit.CONNECTION_TYPES, connectionType) < 0)
				response.error = echtzeit.Error.conntypeMismatch(connectionType);

			if (!connectionType) response.error = echtzeit.Error.parameterMissing('connectionType');

			response.successful = !response.error;

			if (!response.successful) {
				delete response.clientId;
				return callback.call(context, response);
			}

			if (message.connectionType === 'eventsource') {
				message.advice = message.advice || {};
				message.advice.timeout = 0;
			}
			this._engine.connect(response.clientId, message.advice, function(events) {
				callback.call(context, [response].concat(events));
			});
		}, this);
	},

	// MUST contain  * clientId
	// MAY contain   * ext
	//               * id
	disconnect: function(message, local, callback, context) {
		var response = this._makeResponse(message),
				clientId = message.clientId;

		this._engine.clientExists(clientId, function(exists) {
			if (!exists)   response.error = echtzeit.Error.clientUnknown(clientId);
			if (!clientId) response.error = echtzeit.Error.parameterMissing('clientId');

			response.successful = !response.error;
			if (!response.successful) delete response.clientId;

			if (response.successful) this._engine.destroyClient(clientId);
			callback.call(context, response);
		}, this);
	},

	// MUST contain  * clientId
	//               * subscription
	// MAY contain   * ext
	//               * id
	subscribe: function(message, local, callback, context) {
		var response     = this._makeResponse(message),
				clientId     = message.clientId,
				subscription = message.subscription,
				channel;

		subscription = subscription ? [].concat(subscription) : [];

		this._engine.clientExists(clientId, function(exists) {
			if (!exists)               response.error = echtzeit.Error.clientUnknown(clientId);
			if (!clientId)             response.error = echtzeit.Error.parameterMissing('clientId');
			if (!message.subscription) response.error = echtzeit.Error.parameterMissing('subscription');

			response.subscription = message.subscription || [];

			for (var i = 0, n = subscription.length; i < n; i++) {
				channel = subscription[i];

				if (response.error) break;
				if (!local && !echtzeit.Channel.isSubscribable(channel)) response.error = echtzeit.Error.channelForbidden(channel);
				if (!echtzeit.Channel.isValid(channel))                  response.error = echtzeit.Error.channelInvalid(channel);

				if (response.error) break;
				this._engine.subscribe(clientId, channel);
			}

			response.successful = !response.error;
			callback.call(context, response);
		}, this);
	},

	// MUST contain  * clientId
	//               * subscription
	// MAY contain   * ext
	//               * id
	unsubscribe: function(message, local, callback, context) {
		var response     = this._makeResponse(message),
				clientId     = message.clientId,
				subscription = message.subscription,
				channel;

		subscription = subscription ? [].concat(subscription) : [];

		this._engine.clientExists(clientId, function(exists) {
			if (!exists)               response.error = echtzeit.Error.clientUnknown(clientId);
			if (!clientId)             response.error = echtzeit.Error.parameterMissing('clientId');
			if (!message.subscription) response.error = echtzeit.Error.parameterMissing('subscription');

			response.subscription = message.subscription || [];

			for (var i = 0, n = subscription.length; i < n; i++) {
				channel = subscription[i];

				if (response.error) break;
				if (!local && !echtzeit.Channel.isSubscribable(channel)) response.error = echtzeit.Error.channelForbidden(channel);
				if (!echtzeit.Channel.isValid(channel))                  response.error = echtzeit.Error.channelInvalid(channel);

				if (response.error) break;
				this._engine.unsubscribe(clientId, channel);
			}

			response.successful = !response.error;
			callback.call(context, response);
		}, this);
	}
});

echtzeit.extend(echtzeit.Server.prototype, echtzeit.Logging);
echtzeit.extend(echtzeit.Server.prototype, echtzeit.Extensible);

echtzeit.Server.Socket = echtzeit.Class({
	initialize: function(server, socket, request) {
		this._server  = server;
		this._socket  = socket;
		this._request = request;
	},

	send: function(message) {
		this._server.pipeThroughExtensions('outgoing', message, this._request, function(pipedMessage) {
			if (this._socket)
				this._socket.send(echtzeit.toJSON([pipedMessage]));
		}, this);
	},

	close: function() {
		if (this._socket) this._socket.close();
		delete this._socket;
	}
});

echtzeit.Transport.NodeLocal = echtzeit.extend(echtzeit.Class(echtzeit.Transport, {
	batching: false,

	request: function(messages) {
		messages = echtzeit.copyObject(messages);
		this.endpoint.process(messages, null, function(replies) {
			this._receive(echtzeit.copyObject(replies));
		}, this);
	}
}), {
	isUsable: function(client, endpoint, callback, context) {
		callback.call(context, endpoint instanceof echtzeit.Server);
	}
});

echtzeit.Transport.register('in-process', echtzeit.Transport.NodeLocal);

echtzeit.Transport.WebSocket = echtzeit.extend(echtzeit.Class(echtzeit.Transport, {
	UNCONNECTED:  1,
	CONNECTING:   2,
	CONNECTED:    3,

	batching:     false,

	isUsable: function(callback, context) {
		this.callback(function() { callback.call(context, true) });
		this.errback(function() { callback.call(context, false) });
		this.connect();
	},

	request: function(messages) {
		this._pending = this._pending || new echtzeit.Set();
		for (var i = 0, n = messages.length; i < n; i++) this._pending.add(messages[i]);

		this.callback(function(socket) {
			if (!socket) return;
			socket.send(echtzeit.toJSON(messages));
		}, this);

		this.connect();
		var self = this;

		return {
			abort: function() {
				self.callback(function(socket) { socket.close() });
			}
		};
	},

	connect: function() {
		if (echtzeit.Transport.WebSocket._unloaded) return;

		this._state = this._state || this.UNCONNECTED;
		if (this._state !== this.UNCONNECTED) return;
		this._state = this.CONNECTING;

		var socket = this._createSocket();
		if (!socket) return this.setDeferredStatus('failed');

		var self = this;

		socket.onopen = function() {
			if (socket.headers) self._storeCookies(socket.headers['set-cookie']);
			self._socket = socket;
			self._state = self.CONNECTED;
			self._everConnected = true;
			self._ping();
			self.setDeferredStatus('succeeded', socket);
		};

		var closed = false;
		socket.onclose = socket.onerror = function() {
			if (closed) return;
			closed = true;

			var wasConnected = (self._state === self.CONNECTED);
			socket.onopen = socket.onclose = socket.onerror = socket.onmessage = null;

			delete self._socket;
			self._state = self.UNCONNECTED;
			self.removeTimeout('ping');
			self.setDeferredStatus('unknown');

			var pending = self._pending ? self._pending.toArray() : [];
			delete self._pending;

			if (wasConnected) {
				self._handleError(pending, true);
			} else if (self._everConnected) {
				self._handleError(pending);
			} else {
				self.setDeferredStatus('failed');
			}
		};

		socket.onmessage = function(event) {
			var replies = JSON.parse(event.data);
			if (!replies) return;

			replies = [].concat(replies);

			for (var i = 0, n = replies.length; i < n; i++) {
				if (replies[i].successful === undefined) continue;
				self._pending.remove(replies[i]);
			}
			self._receive(replies);
		};
	},

	close: function() {
		if (!this._socket) return;
		this._socket.close();
	},

	_createSocket: function() {
		var url     = echtzeit.Transport.WebSocket.getSocketUrl(this.endpoint),
				headers = echtzeit.copyObject(this._dispatcher.headers),
				options = {headers: headers, ca: this._dispatcher.ca};

		options.headers['Cookie'] = this._getCookies();

		if (echtzeit.WebSocket)        return new echtzeit.WebSocket.Client(url, [], options);
		if (echtzeit.ENV.MozWebSocket) return new MozWebSocket(url);
		if (echtzeit.ENV.WebSocket)    return new WebSocket(url);
	},

	_ping: function() {
		if (!this._socket) return;
		this._socket.send('[]');
		this.addTimeout('ping', this._dispatcher.timeout / 2, this._ping, this);
	}

}), {
	PROTOCOLS: {
		'http:':  'ws:',
		'https:': 'wss:'
	},

	create: function(dispatcher, endpoint) {
		var sockets = dispatcher.transports.websocket = dispatcher.transports.websocket || {};
		sockets[endpoint.href] = sockets[endpoint.href] || new this(dispatcher, endpoint);
		return sockets[endpoint.href];
	},

	getSocketUrl: function(endpoint) {
		endpoint = echtzeit.copyObject(endpoint);
		endpoint.protocol = this.PROTOCOLS[endpoint.protocol];
		return echtzeit.URI.stringify(endpoint);
	},

	isUsable: function(dispatcher, endpoint, callback, context) {
		this.create(dispatcher, endpoint).isUsable(callback, context);
	}
});

echtzeit.extend(echtzeit.Transport.WebSocket.prototype, echtzeit.Deferrable);
echtzeit.Transport.register('websocket', echtzeit.Transport.WebSocket);

if (echtzeit.Event && echtzeit.ENV.onbeforeunload !== undefined)
	echtzeit.Event.on(echtzeit.ENV, 'beforeunload', function() {
		echtzeit.Transport.WebSocket._unloaded = true;
	});

echtzeit.Transport.NodeHttp = echtzeit.extend(echtzeit.Class(echtzeit.Transport, {
	encode: function(messages) {
		return echtzeit.toJSON(messages);
	},

	request: function(messages) {
		var uri     = this.endpoint,
				secure  = (uri.protocol === 'https:'),
				client  = secure ? https : http,
				content = new Buffer(this.encode(messages), 'utf8'),
				self    = this;

		var params  = this._buildParams(uri, content, secure),
				request = client.request(params);

		request.on('response', function(response) {
			self._handleResponse(messages, response);
			self._storeCookies(response.headers['set-cookie']);
		});

		request.on('error', function(error) {
			self._handleError(messages);
		});

		request.end(content);
		return request;
	},

	_buildParams: function(uri, content, secure) {
		var params = {
			method:   'POST',
			host:     uri.hostname,
			port:     uri.port || (secure ? 443 : 80),
			path:     uri.path,
			headers:  echtzeit.extend({
				'Content-Length': content.length,
				'Content-Type':   'application/json',
				'Cookie':         this._getCookies(),
				'Host':           uri.host
			}, this._dispatcher.headers)
		};
		if (this._dispatcher.ca) params.ca = this._dispatcher.ca;
		return params;
	},

	_handleResponse: function(messages, response) {
		var replies = null,
				body    = '',
				self    = this;

		response.setEncoding('utf8');
		response.on('data', function(chunk) { body += chunk });

		response.on('end', function() {
			try {
				replies = JSON.parse(body);
			} catch (e) {}

			if (replies)
				self._receive(replies);
			else
				self._handleError(messages);
		});
	}

}), {
	isUsable: function(dispatcher, endpoint, callback, context) {
		callback.call(context, echtzeit.URI.isURI(endpoint));
	}
});

echtzeit.Transport.register('long-polling', echtzeit.Transport.NodeHttp);

var crypto = require('crypto'),
	fs = require('fs'),
	http = require('http'),
	https = require('https'),
	net = require('net'),
	path = require('path'),
	tls = require('tls'),
	url = require('url'),
	querystring = require('querystring'),

	csprng = require('csprng');

echtzeit.WebSocket = require('faye-websocket');
echtzeit.EventSource = echtzeit.WebSocket.EventSource;
echtzeit.Cookies = require('tough-cookie');

echtzeit.NodeAdapter = echtzeit.Class({
	DEFAULT_ENDPOINT: '/ez',
	SCRIPT_PATH: 'echtzeit.client.js',

	TYPE_JSON: {
		'Content-Type': 'application/json; charset=utf-8'
	},
	TYPE_SCRIPT: {
		'Content-Type': 'text/javascript; charset=utf-8'
	},
	TYPE_TEXT: {
		'Content-Type': 'text/plain; charset=utf-8'
	},

	initialize: function(options) {
		this._options = options || {};
		this._endpoint = this._options.mount || this.DEFAULT_ENDPOINT;
		this._endpointRe = new RegExp('^' + this._endpoint.replace(/\/$/, '') + '(/[^/]*)*(\\.[^\\.]+)?$');
		this._server = new echtzeit.Server(this._options);

		this._static = new echtzeit.StaticServer(path.dirname(__filename) + '/client', /\.(?:js|map)$/);
		this._static.map(path.basename(this._endpoint) + '.js', this.SCRIPT_PATH);
		this._static.map('client.js', this.SCRIPT_PATH);

		var extensions = this._options.extensions;
		if (!extensions) return;

		extensions = [].concat(extensions);
		for (var i = 0, n = extensions.length; i < n; i++)
			this.addExtension(extensions[i]);
	},

	listen: function() {
		throw new Error('The listen() method is deprecated - use the attach() method to bind echtzeit to an http.Server');
	},

	addExtension: function(extension) {
		return this._server.addExtension(extension);
	},

	removeExtension: function(extension) {
		return this._server.removeExtension(extension);
	},

	close: function() {
		return this._server.close();
	},

	getClient: function() {
		return this._client = this._client || new echtzeit.Client(this._server);
	},

	attach: function(httpServer) {
		this._overrideListeners(httpServer, 'request', 'handle');
		this._overrideListeners(httpServer, 'upgrade', 'handleUpgrade');
	},

	_overrideListeners: function(httpServer, event, method) {
		var listeners = httpServer.listeners(event),
			self = this;

		httpServer.removeAllListeners(event);

		httpServer.on(event, function(request) {
			if (self.check(request)) return self[method].apply(self, arguments);

			for (var i = 0, n = listeners.length; i < n; i++)
				listeners[i].apply(this, arguments);
		});
	},

	check: function(request) {
		var path = url.parse(request.url, true).pathname;
		return !!this._endpointRe.test(path);
	},

	handle: function(request, response) {
		var requestUrl = url.parse(request.url, true),
			requestMethod = request.method,
			self = this;

		request.originalUrl = request.url;

		request.on('error', function(error) {
			self._returnError(response, error)
		});
		response.on('error', function(error) {
			self._returnError(null, error)
		});

		if (this._static.test(requestUrl.pathname))
			return this._static.call(request, response);

		// http://groups.google.com/group/faye-users/browse_thread/thread/4a01bb7d25d3636a
		if (requestMethod === 'OPTIONS' || request.headers['access-control-request-method'] === 'POST')
			return this._handleOptions(response);

		if (echtzeit.EventSource.isEventSource(request))
			return this.handleEventSource(request, response);

		if (requestMethod === 'GET')
			return this._callWithParams(request, response, requestUrl.query);

		if (requestMethod === 'POST')
			return this._concatStream(request, function(data) {
				var type = (request.headers['content-type'] || '').split(';')[0],
					params = (type === 'application/json') ? {
						message: data
					} : querystring.parse(data);

				request.body = data;
				this._callWithParams(request, response, params);
			}, this);

		this._returnError(response, {
			message: 'Unrecognized request type'
		});
	},

	_callWithParams: function(request, response, params) {
		if (!params.message)
			return this._returnError(response, {
				message: 'Received request with no message: ' + this._formatRequest(request)
			});

		try {
			this.debug('Received message via HTTP ' + request.method + ': ?', params.message);

			var message = JSON.parse(params.message),
				jsonp = params.jsonp || echtzeit.JSONP_CALLBACK,
				isGet = (request.method === 'GET'),
				type = isGet ? this.TYPE_SCRIPT : this.TYPE_JSON,
				headers = echtzeit.extend({}, type),
				origin = request.headers.origin;

			if (origin) headers['Access-Control-Allow-Origin'] = origin;
			headers['Cache-Control'] = 'no-cache, no-store';

			this._server.process(message, request, function(replies) {
				var body = echtzeit.toJSON(replies);
				if (isGet) body = jsonp + '(' + this._jsonpEscape(body) + ');';
				headers['Content-Length'] = new Buffer(body, 'utf8').length.toString();
				headers['Connection'] = 'close';

				this.debug('HTTP response: ?', body);
				response.writeHead(200, headers);
				response.end(body);
			}, this);
		} catch (error) {
			this._returnError(response, error);
		}
	},

	_jsonpEscape: function(json) {
		return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
	},

	handleUpgrade: function(request, socket, head) {
		var ws = new echtzeit.WebSocket(request, socket, head, null, {
				ping: this._options.ping
			}),
			clientId = null,
			self = this;

		request.originalUrl = request.url;

		ws.onmessage = function(event) {
			try {
				self.debug('Received message via WebSocket[' + ws.version + ']: ?', event.data);

				var message = JSON.parse(event.data),
					cid = echtzeit.clientIdFromMessages(message);

				if (clientId && cid && cid !== clientId) self._server.closeSocket(clientId, false);
				self._server.openSocket(cid, ws, request);
				clientId = cid;

				self._server.process(message, request, function(replies) {
					if (ws) ws.send(echtzeit.toJSON(replies));
				});
			} catch (e) {
				self.error(e.message + '\nBacktrace:\n' + e.stack);
			}
		};

		ws.onclose = function(event) {
			self._server.closeSocket(clientId);
			ws = null;
		};
	},

	handleEventSource: function(request, response) {
		var es = new echtzeit.EventSource(request, response, {
				ping: this._options.ping
			}),
			clientId = es.url.split('/').pop(),
			self = this;

		this.debug('Opened EventSource connection for ?', clientId);
		this._server.openSocket(clientId, es, request);

		es.onclose = function(event) {
			self._server.closeSocket(clientId);
			es = null;
		};
	},

	_handleOptions: function(response) {
		var headers = {
			'Access-Control-Allow-Credentials': 'false',
			'Access-Control-Allow-Headers': 'Accept, Content-Type, Pragma, X-Requested-With',
			'Access-Control-Allow-Methods': 'POST, GET, PUT, DELETE, OPTIONS',
			'Access-Control-Allow-Origin': '*',
			'Access-Control-Max-Age': '86400'
		};
		response.writeHead(200, headers);
		response.end('');
	},

	_concatStream: function(stream, callback, context) {
		var chunks = [],
			length = 0;

		stream.on('data', function(chunk) {
			chunks.push(chunk);
			length += chunk.length;
		});

		stream.on('end', function() {
			var buffer = new Buffer(length),
				offset = 0;

			for (var i = 0, n = chunks.length; i < n; i++) {
				chunks[i].copy(buffer, offset);
				offset += chunks[i].length;
			}
			callback.call(context, buffer.toString('utf8'));
		});
	},

	_formatRequest: function(request) {
		var method = request.method.toUpperCase(),
			string = 'curl -X ' + method;

		string += " 'http://" + request.headers.host + request.url + "'";
		if (method === 'POST') {
			string += " -H 'Content-Type: " + request.headers['content-type'] + "'";
			string += " -d '" + request.body + "'";
		}
		return string;
	},

	_returnError: function(response, error) {
		var message = error.message;
		if (error.stack) message += '\nBacktrace:\n' + error.stack;
		this.error(message);

		if (!response) return;

		response.writeHead(400, this.TYPE_TEXT);
		response.end('Bad request');
	}
});

for (var method in echtzeit.Publisher)(function(method) {
	echtzeit.NodeAdapter.prototype[method] = function() {
		return this._server._engine[method].apply(this._server._engine, arguments);
	};
})(method);

echtzeit.extend(echtzeit.NodeAdapter.prototype, echtzeit.Logging);
echtzeit.StaticServer = echtzeit.Class({
	initialize: function(directory, pathRegex) {
		this._directory = directory;
		this._pathRegex = pathRegex;
		this._pathMap = {};
		this._index = {};
	},

	map: function(requestPath, filename) {
		this._pathMap[requestPath] = filename;
	},

	test: function(pathname) {
		return this._pathRegex.test(pathname);
	},

	call: function(request, response) {
		var pathname = url.parse(request.url, true).pathname,
			filename = path.basename(pathname);

		filename = this._pathMap[filename] || filename;
		this._index[filename] = this._index[filename] || {};

		var cache = this._index[filename],
			fullpath = path.join(this._directory, filename);

		try {
			cache.content = cache.content || fs.readFileSync(fullpath);
			cache.digest = cache.digest || crypto.createHash('sha1').update(cache.content).digest('hex');
			cache.mtime = cache.mtime || fs.statSync(fullpath).mtime;
		} catch (e) {
			response.writeHead(404, {});
			return response.end();
		}

		var type = /\.js$/.test(pathname) ? 'TYPE_SCRIPT' : 'TYPE_JSON',
			ims = request.headers['if-modified-since'];

		var headers = {
			'ETag': cache.digest,
			'Last-Modified': cache.mtime.toGMTString()
		};

		if (request.headers['if-none-match'] === cache.digest) {
			response.writeHead(304, headers);
			response.end();
		} else if (ims && cache.mtime <= new Date(ims)) {
			response.writeHead(304, headers);
			response.end();
		} else {
			headers['Content-Length'] = cache.content.length;
			echtzeit.extend(headers, echtzeit.NodeAdapter.prototype[type]);
			response.writeHead(200, headers);
			response.end(cache.content);
		}
	}
});

require("r1-telemetry");
if (typeof module !== 'undefined')
        module.exports = echtzeit;
else if (typeof window !== 'undefined')
        window.echtzeit = echtzeit;
